 #include <Arduino.h>
#include <MD_Parola.h>
//#include <MD_MAX72XX.h>
#ifdef ESP32
#include <WiFi.h>
#else
#include <ESP8266WiFi.h>
#endif
#include <WiFiClientSecure.h>
#include <UniversalTelegramBot.h>
#include <ArduinoJson.h>
#include <IotWebConf.h>
#include <time.h>
#include <ESP32Encoder.h>
#include <RTClib.h>
#include <Preferences.h>

// Constants and Macros
#define BOT_TOKEN "6824249584:AAFiZPhLaIB27YrVF_MX1HqvhKNwlUKh9oQ"
#define CHAT_ID "818675367"
#define HARDWARE_TYPE MD_MAX72XX::FC16_HW
#define MAX_DEVICES 4
#define CS_PIN 5
#define ENCODER_PIN_A 16
#define ENCODER_PIN_B 17
#define PRESS_PIN 13
#define LED_PIN 2
#define BOT_REQUEST_DELAY 1000
#define WIFI_INITIAL_AP_PASSWORD "m12345678"
#define THING_NAME "testThing"

// Global Variables
Preferences preferences;
RTC_DS1307 rtc;
ESP32Encoder encoder;
MD_Parola myDisplay = MD_Parola(HARDWARE_TYPE, CS_PIN, MAX_DEVICES);
WiFiClientSecure client;
UniversalTelegramBot bot(BOT_TOKEN, client);
unsigned long lastTimeBotRan;
bool ledState = LOW;
String scrollMessage = "no message";
String timeNow, dateNow;
int hours = 0, minutes = 0, day = 0, month = 0, year = 0, amPm = 1;
unsigned long lastDisplayTime = 0;
bool useFirstScroll = true;

// IoT Web Configuration
DNSServer dnsServer;
WebServer server(80);
IotWebConf iotWebConf(THING_NAME, &dnsServer, &server, WIFI_INITIAL_AP_PASSWORD);

// Function Prototypes
void resetEveryTwoHours();
void writeToFlash(const char *key, int valueToStore);
int readFromFlash(const char *key);
int nat(int number);
bool longpress(int pin, int dtime, int state);
String longToString(long number);
void convertTo24Hour(int hour12, int minute, const String &period, int &hour24, int &minute24);
void handleEncoder();
String formatTime12Hour(int hour, int minute, bool &isPM);
void handleRoot();
void handleEncoderTask(void *parameter);
void handleTimeTask(void *parameter);
void handleDisplayTask(void *parameter);
String handleNewMessages(int numNewMessages);
void handleBotTask(void *parameter);

// Function Definitions

void writeToFlash(const char *key, int valueToStore)
{
  preferences.putInt(key, valueToStore);
  Serial.printf("Stored integer at %s: %d\n", key, valueToStore);
}

int readFromFlash(const char *key)
{
  int storedValue = preferences.getInt(key, 0);
  Serial.printf("Read integer from %s: %d\n", key, storedValue);
  return storedValue;
}

int nat(int number)
{
  return number == 0 ? 1 : 0;
}

bool longpress(int pin, int dtime, int state)
{
  if (digitalRead(pin) == nat(state))
  {
    return false;
  }
  int i = 0;
  while (digitalRead(pin) == state && i <= 10)
  {
    delay(dtime / 10);
    if (i == 10)
    {
      return true;
    }
    i++;
  }
  return false;
}

String longToString(long number)
{
  char buffer[20];
  sprintf(buffer, "%ld", number);
  return String(buffer);
}

void convertTo24Hour(int hour12, int minute, const String &period, int &hour24, int &minute24)
{
  hour24 = hour12;
  minute24 = minute;
  if (period == "PM" && hour12 != 12)
  {
    hour24 += 12;
  }
  if (period == "AM" && hour12 == 12)
  {
    hour24 = 0;
  }
}

void handleEncoder()
{
  String isPMorAM = "";
  int pressCounter = 0;
  myDisplay.print("T.set");
  delay(1000);
  for (;;)
  {
    static long oldPosition = -999;
    long newPosition = encoder.getCount();
    if (longpress(PRESS_PIN, 1000, 0))
    {
      encoder.clearCount();
      pressCounter++;
      oldPosition = -999;
      newPosition = 1;
    }
    if (newPosition != oldPosition)
    {
      oldPosition = newPosition;
      if (pressCounter == 0)
      {
        newPosition = constrain(newPosition, 1, 12);
        hours = newPosition;
        myDisplay.print("Hor>" + longToString(hours));
      }
      else if (pressCounter == 1)
      {
        newPosition = constrain(newPosition, 1, 100);
        amPm = newPosition;
        isPMorAM = (amPm % 2 == 0) ? "AM" : "PM";
        myDisplay.print(">" + isPMorAM);
      }
      else if (pressCounter == 2)
      {
        newPosition = constrain(newPosition, 1, 59);
        minutes = newPosition;
        myDisplay.print("Min>" + longToString(minutes));
      }
      else if (pressCounter == 3)
      {
        newPosition = constrain(newPosition, 1, 31);
        day = newPosition;
        myDisplay.print("Day>" + longToString(day));
      }
      else if (pressCounter == 4)
      {
        newPosition = constrain(newPosition, 1, 12);
        month = newPosition;
        myDisplay.print("Mon>" + longToString(month));
      }
      else if (pressCounter == 5)
      {
        newPosition = constrain(newPosition, 1, 99);
        year = newPosition;
        myDisplay.print(">" + longToString(2000 + year));
      }
      else if (pressCounter == 6)
      {
        int hour24, minute24;
        convertTo24Hour(hours, minutes, isPMorAM, hour24, minute24);
        rtc.adjust(DateTime(2000 + year, month, day, hour24, minutes, 0));
        myDisplay.print("EXIT");
        delay(1000);
        break;
      }
    }
  }
}


void resetEveryTwoHours()
{
  static unsigned long lastResetTime = 0;
  unsigned long currentTime = millis();
  if (currentTime - lastResetTime >= 7200000)
  { // 5 minutes (300,000 milliseconds)
    esp_restart();
  }
}

String formatTime12Hour(int hour, int minute, bool &isPM)
{
  isPM = (hour >= 12);
  if (hour > 12)
    hour -= 12;
  if (hour == 0)
    hour = 12;
  char timeString[6];
  sprintf(timeString, "%d:%02d", hour, minute);
  return String(timeString);
}

void handleRoot()
{
  if (iotWebConf.handleCaptivePortal())
  {
    return;
  }
  String s = "<!DOCTYPE html><html lang=\"en\"><head><meta name=\"viewport\" content=\"width=device-width, initial-scale=1, user-scalable=no\"/>";
  s += "<title>IotWebConf 01 Minimal</title></head><body>";
  s += "Go to <a href='config'>configure page</a> to change settings.";
  s += "</body></html>\n";
  server.send(200, "text/html", s);
}

void handleEncoderTask(void *parameter)
{
  int oldPosition;
  for (;;)
  {
    int newPosition = encoder.getCount();
    if (oldPosition != newPosition)
    {
      Serial.println(newPosition);
    }
    oldPosition = newPosition;
    delay(100); // Delay for stability
  }
}

void handleTimeTask(void *parameter)
{
  for (;;)
  {
    DateTime now = rtc.now();
    bool isPM;
    String timeString = formatTime12Hour(now.hour(), now.minute(), isPM);
    String displayString = timeString + (isPM ? "." : "");
    dateNow = String(now.year()) + "/" + String(now.month()) + "/" + String(now.day());
    timeNow = displayString;
    delay(1000); // Update every 1 second
  }
}

void handleDisplayTask(void *parameter)
{
  for (;;)
  {
    if (millis() - lastDisplayTime >= 10000)
    { // Every 10 seconds
      if (myDisplay.displayAnimate())
      {
        if (useFirstScroll)
        {
          myDisplay.displayScroll(scrollMessage.c_str(), PA_CENTER, PA_SCROLL_LEFT, 50);
        }
        else
        {
          myDisplay.displayScroll(dateNow.c_str(), PA_CENTER, PA_SCROLL_LEFT, 50);
        }
        myDisplay.displayReset();
        lastDisplayTime = millis();
        useFirstScroll = !useFirstScroll; // Toggle the flag to alternate the scroll functions
      }
    }
    else
    {
      if (myDisplay.displayAnimate())
      {
        myDisplay.displayText(timeNow.c_str(), PA_CENTER, myDisplay.getSpeed(), 10000, PA_SCROLL_DOWN, PA_SCROLL_DOWN);
        myDisplay.displayReset();
      }
    }
    if (longpress(PRESS_PIN, 1000, 0))
    {
      handleEncoder();
    }
    delay(50);
  }
}

String handleNewMessages(int numNewMessages)
{
  for (int i = 0; i < numNewMessages; i++)
  {
    String chat_id = String(bot.messages[i].chat_id);
    if (chat_id != CHAT_ID)
    {
      bot.sendMessage(chat_id, "Unauthorized user", "");
      continue;
    }
    String text = bot.messages[i].text;
    scrollMessage = text;
    bot.sendMessage(CHAT_ID, scrollMessage, "");
    return text;
  }
  return "";
}

void handleBotTask(void *parameter)
{
  for (;;)
  {
    if (millis() > lastTimeBotRan + BOT_REQUEST_DELAY)
    {
      int numNewMessages = bot.getUpdates(bot.last_message_received + 1);
      while (numNewMessages)
      {
        Serial.println("got response");
        Serial.println(handleNewMessages(numNewMessages));
        numNewMessages = bot.getUpdates(bot.last_message_received + 1);
      }
      lastTimeBotRan = millis();
    }
    delay(100);
  }
}

void setup()
{
  Serial.begin(115200);

  pinMode(ENCODER_PIN_A, INPUT_PULLUP);
  pinMode(ENCODER_PIN_B, INPUT_PULLUP);
  pinMode(PRESS_PIN, INPUT_PULLUP);
  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, ledState);

  if (!rtc.begin())
  {
    Serial.println("RTC module is NOT found");
  }

  encoder.attachSingleEdge(ENCODER_PIN_A, ENCODER_PIN_B);
  encoder.clearCount();

  iotWebConf.init();
  server.on("/", handleRoot);
  server.on("/config", []
            { iotWebConf.handleConfig(); });
  server.onNotFound([]
                    { iotWebConf.handleNotFound(); });

  Serial.println("Starting up...");
  Serial.println(WiFi.localIP());

  myDisplay.begin();
  myDisplay.setIntensity(2);
  myDisplay.displayClear();

  preferences.begin("my-app", false);

#ifdef ESP32
  client.setCACert(TELEGRAM_CERTIFICATE_ROOT);
#endif

#ifdef ESP8266
  configTime(0, 0, "pool.ntp.org");
  client.setTrustAnchors(&cert);
#elif defined(ESP32)
  configTime(0, 0, "pool.ntp.org");
#endif

  xTaskCreatePinnedToCore(handleEncoderTask, "EncoderTask", 10000, NULL, 1, NULL, 1);
  xTaskCreatePinnedToCore(handleDisplayTask, "DisplayTask", 10000, NULL, 1, NULL, 1);
  xTaskCreatePinnedToCore(handleBotTask, "BotTask", 10000, NULL, 1, NULL, 1);
  xTaskCreatePinnedToCore(handleTimeTask, "TimeTask", 4096, NULL, 1, NULL, 1);
}

void loop()
{
  iotWebConf.doLoop();
  resetEveryTwoHours();
}