#include <Arduino.h>
#include <MD_Parola.h>
#include <esp_task_wdt.h>
#include <time/time.h>
#include <telegram/telegram.h>
#include <parsers/parsers.h>
#include <utils/utils.h>
#include <encoder/encoder.h>

#define HARDWARE_TYPE MD_MAX72XX::FC16_HW
#define MAX_DEVICES 4
#define CS_PIN 5
#define PRESS_PIN 32

MD_Parola myDisplay = MD_Parola(HARDWARE_TYPE, CS_PIN, MAX_DEVICES);

unsigned long lastDisplayTime = 0;
bool useFirstScroll = true;
uint8_t *customAnim = nullptr;
uint8_t F_CUSTOM_ANIM = 6;
uint8_t W_CUSTOM_ANIM = 8;
uint8_t F_CUSTOM_ANIM1 = 6;
uint8_t W_CUSTOM_ANIM1 = 8;
const uint8_t F_PMAN1 = 6;
const uint8_t W_PMAN1 = 8;
const uint8_t PROGMEM pacman1[F_PMAN1 * W_PMAN1] = // gobbling pacman animation
    {0x00,0x81,0xc3,0xe7,0xff,0x7e,0x7e,0x3c,0x00,0x42,0xe7,0xe7,0xff,0xff,0x7e,0x3c,0x24,0x66,0xe7,0xff,0xff,0xff,0x7e,0x3c,0x3c,0x7e,0xff,0xff,0xff,0xff,0x7e,0x3c,0x24,0x66,0xe7,0xff,0xff,0xff,0x7e,0x3c,0x00,0x42,0xe7,0xe7,0xff,0xff,0x7e,0x3c,};
const uint8_t F_PMAN2 = 6;
const uint8_t W_PMAN2 = 18;
const uint8_t PROGMEM pacman2[F_PMAN2 * W_PMAN2] = // ghost pursued by a pacman
    {0x00,0x81,0xc3,0xe7,0xff,0x7e,0x7e,0x3c,0x00,0x00,0x00,0xfe,0x7b,0xf3,0x7f,0xfb,0x73,0xfe,0x00,0x42,0xe7,0xe7,0xff,0xff,0x7e,0x3c,0x00,0x00,0x00,0xfe,0x7b,0xf3,0x7f,0xfb,0x73,0xfe,0x24,0x66,0xe7,0xff,0xff,0xff,0x7e,0x3c,0x00,0x00,0x00,0xfe,0x7b,0xf3,0x7f,0xfb,0x73,0xfe,0x3c,0x7e,0xff,0xff,0xff,0xff,0x7e,0x3c,0x00,0x00,0x00,0xfe,0x7b,0xf3,0x7f,0xfb,0x73,0xfe,0x24,0x66,0xe7,0xff,0xff,0xff,0x7e,0x3c,0x00,0x00,0x00,0xfe,0x7b,0xf3,0x7f,0xfb,0x73,0xfe,0x00,0x42,0xe7,0xe7,0xff,0xff,0x7e,0x3c,0x00,0x00,0x00,0xfe,0x7b,0xf3,0x7f,0xfb,0x73,0xfe,};
const uint8_t F_HEART = 5;
const uint8_t W_HEART = 9;
const uint8_t PROGMEM heart[F_HEART * W_HEART] =
    {0x0e,0x11,0x21,0x42,0x84,0x42,0x21,0x11,0x0e,0x0e,0x1f,0x33,0x66,0xcc,0x66,0x33,0x1f,0x0e,0x0e,0x1f,0x3f,0x7e,0xfc,0x7e,0x3f,0x1f,0x0e,0x0e,0x1f,0x33,0x66,0xcc,0x66,0x33,0x1f,0x0e,0x0e,0x11,0x21,0x42,0x84,0x42,0x21,0x11,0x0e,};
uint8_t customChar[] = { 0x07, 0x40, 0x7C, 0x42, 0xC3, 0x42, 0x7C, 0x40 };
uint8_t customChar1[] = {0x08 , 0x0E,0x11,0x21,0x42,0x42,0x21,0x11,0x0E};
const uint16_t PAUSE_TIME = 1000; // in milliseconds

void handleDisplayTask(void *parameter)
{
  for (;;)
  {
    if (millis() - lastDisplayTime >= 10000)
    { // Every 10 seconds
      if (myDisplay.displayAnimate())
      {
        if (useFirstScroll)
        {
          if (scrolling == "pacman")
          {
            myDisplay.displayText("", PA_CENTER, 50, PAUSE_TIME, PA_SPRITE, PA_SPRITE);
            myDisplay.setSpriteData(pacman1, W_PMAN1, F_PMAN1, pacman2, W_PMAN2, F_PMAN2);
          }
          else if (scrolling == "heart")
          {
            myDisplay.displayText("", PA_CENTER, 50, PAUSE_TIME, PA_SPRITE);
            myDisplay.setSpriteData(heart, W_HEART, F_HEART, heart, W_HEART, F_HEART);
          }
          else if (scrolling.startsWith("anim"))
          {
            parseSpriteData(scrolling, customAnim, W_CUSTOM_ANIM, F_CUSTOM_ANIM);
            myDisplay.displayText("", PA_CENTER, 50, PAUSE_TIME, PA_SPRITE, PA_SPRITE);
            myDisplay.setSpriteData(customAnim, F_CUSTOM_ANIM, W_CUSTOM_ANIM, customAnim, F_CUSTOM_ANIM, W_CUSTOM_ANIM);
          }
          else
          {
            myDisplay.displayScroll(scrolling.c_str(), PA_CENTER, PA_SCROLL_LEFT, 50);
          }
        }
        else
        {
          myDisplay.displayScroll(dateNow.c_str(), PA_CENTER, PA_SCROLL_LEFT, 50);
        }
        delay(100);
        myDisplay.displayReset();
        lastDisplayTime = millis();
        useFirstScroll = !useFirstScroll; // Toggle the flag to alternate the scroll functions
      }
    }
    else
    {
      delay(5);
      if (myDisplay.displayAnimate())
      {
        myDisplay.displayText(timeNow.c_str(), PA_CENTER, myDisplay.getSpeed(), 10000, PA_SCROLL_DOWN, PA_SCROLL_DOWN);
        delay(100);
        myDisplay.displayReset();
      }
    }
    if (longpress(PRESS_PIN, 1000, 0))
    {
      handleEncoder();
    }
    HandleAlarmTask();
    esp_task_wdt_reset();                // Reset the watchdog timer
    vTaskDelay(10 / portTICK_PERIOD_MS); // Small delay to yield
  }
}